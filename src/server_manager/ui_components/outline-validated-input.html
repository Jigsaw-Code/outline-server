<!--
  Copyright 2020 The Outline Authors

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<!-- outline-validated-input
    This is an input, with a cancel and a save button, which performs client-side validation and has an
    event-based hook for server-side evaluation.

    Attributes:
        * name: A unique name used to build element id's.  Default: null
        * editable: Is this input editable?  Default: false
        * visible: Is this input visible?  Default: false
        * label: The label for the input.  Default: null
        * value: The initial value entered in the input.  SHOULD be a valid value.  Default: null
        * allowed-pattern: Regex describing what inputs are allowed.  Users will be prevented from
            entering inputs which don't follow the pattern.  Default: ".*"
        * max-length: The number of characters allowed in the input.  Default: Number.POSITIVE_INFINITY
        * client-side-validator: A function which takes a string and returns whether or not the current
            value of the input is valid.  This function will be called on every keystroke. Default: () => true
        * client-side-validation-failure-message: The displayed failure message if the client side
            validator fails. Default: null
        * event: The name of the event fired when the save button is tapped.  Passes the
            current input value as "value" and the Polymer object as "ui".  The handler for this event
            MUST call ui.setSavedState() or ui.setErrorState(message) depending on its result. Default: null
 -->

<link rel='import' href='./cloud-install-styles.html'>
<link rel='import' href='./outline-server-settings-styles.html'>

<dom-module id='outline-validated-input'>
    <template>
        <style include='cloud-install-styles'></style>
        <style include='outline-server-settings-styles'></style>
        <style>
            [id$=Container] {
                display: flex;
                justify-content: space-between;
                align-items: center;
                max-width: 545px;
            }

            [id$=SaveButton] {
                background: var(--primary-green);
                color: #fff;
                height: 36px;
                width: 83px;
            }

            [id$=SaveButton][disabled] {
                background-color: rgba(255, 255, 255, .12);
                color: rgba(255, 255, 255, .3);
            }

            [id$=CancelButton] {
                color: #fff;
                height: 36px;
                width: 83px;
            }

            [id$=CancelButton][disabled] {
                color: rgba(255, 255, 255, 0.3);
                background-color: rgba(0, 0, 0, 0);
            }
        </style>
        <div id="[[name]]Container" hidden$="[[!visible]]">
            <!-- We use on-focus instead of on-tap to handle the case where text is selected but the tap event isn't fired. -->
            <paper-input id="[[name]]Input" readonly$="[[!editable]]" allowed-pattern="[[allowedPattern]]"
                value="[[value]]" label="[[label]]" maxlength="[[maxLength]]" on-focus="_enterEditingState"
                on-keyup="_onKeyUp" always-float-label>
            </paper-input>
            <paper-button id="[[name]]CancelButton" hidden$="[[!_showButtons]]" disabled$="[[!_enableButtons]]"
                on-tap="_cancel">
                [[localize('cancel')]]
            </paper-button>
            <paper-button id="[[name]]SaveButton" hidden$="[[!_showButtons]]" disabled$="[[!_enableButtons]]"
                on-tap="_save">
                [[localize('save')]]
            </paper-button>
        </div>
    </template>
    <script>
        Polymer({
            is: 'outline-validated-input',
            properties: {
                // Properties affecting the whole element
                name: { type: String, readonly: true, value: null },
                editable: { type: Boolean, value: false },
                visible: { type: Boolean, value: false },
                // Properties affecting the input
                label: { type: String, readonly: true, value: null },
                allowedPattern: { type: String, value: ".*" },
                maxLength: { type: Number, value: Number.POSITIVE_INFINITY },
                value: { type: String, value: null },
                // `value` here is evaluated.  If it were simply `() => true`, then clientSideValidator
                // would default to just `true`, not a function returning true.
                // Note also that we can't use paper-input's validator attribute because it will fight
                // with any server-side validation and cause unpredictable results.
                clientSideValidator: { type: Function, readonly: true, value: () => { return () => true; } },
                clientSideValidationFailureMessage: { type: String, value: null },
                // Properties affecting the buttons
                _showButtons: { type: Boolean, value: false },
                _enableButtons: { type: Boolean, value: false },
                // Other properties
                event: { type: String, value: null },
                localize: { type: Function, readonly: true }
            },
            _select: function (idSuffix) { return this.$$(`#${this.name}${idSuffix}`); },
            _onKeyUp: function (e) {
                const input = this._select("Input");
                if (e.key === 'Escape') {
                    this._cancel();
                    input.blur();
                    return;
                } else if (e.key === 'Enter') {
                    if (!input.invalid) {
                        this._save();
                        input.blur();
                    }
                    return;
                }
                if (!this.clientSideValidator(input.value)) {
                    input.invalid = true;
                    this._select("SaveButton").disabled = true;
                    input.errorMessage = this.clientSideValidationFailureMessage;
                } else {
                    input.invalid = false;
                    this._select("SaveButton").disabled = false;
                }
            },
            _cancel: function () {
                const input = this._select("Input");
                input.value = this.value;
                input.invalid = false;
                this._showButtons = false;
            },
            _save: function () {
                const input = this._select("Input");
                const value = input.value;
                if (value === this.value) {
                    this._cancel();
                    return;
                };
                this._enableButtons = false;
                input.readonly = true;
                input.invalid = false;

                // We use this heuristic to avoid having to pass a constructor as an attribute
                const numberValue = Number(value);
                const typedValue = Number.isNaN(numberValue) ? value : numberValue;

                this.fire(this.event, {
                    value: typedValue,
                    ui: this
                });
            },
            _enterEditingState: function () {
                if (!this.editable) {
                    return;
                }
                this._showButtons = true;
                this._select("CancelButton").disabled = false;
                this._select("SaveButton").disabled = this._select("Input").invalid;
            },
            enterSavedState: function () {
                const input = this._select("Input");
                this.value = input.value;
                this._showButtons = false;
                input.readonly = false;
            },
            enterErrorState: function (message) {
                const input = this._select("Input");
                this._enableButtons = true;
                input.errorMessage = message;
                input.invalid = true;
                input.readonly = false;
                input.focus();
            }
        });
    </script>
</dom-module>